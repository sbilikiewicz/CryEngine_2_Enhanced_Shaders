////////////////////////////////////////////////////////////////////////////
//
//  Crytek Engine Source File.
//  Shader extension
//  Copyright (C), Crytek Studios, 2001-2004.
// -------------------------------------------------------------------------
//  File name:   PostEffectsGame.cfx
//  Version:     v1.00
//  Created:     14/06/2006 by Tiago Sousa
//  Compilers:   
//  Description: Hud/game specific post processing
// -------------------------------------------------------------------------
//  History:
//
//  02/2019  -  New Blood Splats and HQ textures
//              by Sbilikiewicz https://github.com/sbilikiewicz
//
// -------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////

#include "Common.cfi"
#include "ShadeLib.cfi"
#include "PostEffectsLib.cfi"

// Shader global descriptions
float Script : STANDARDSGLOBAL
<
  string Script =
           "NoPreview;"
           "LocalConstants;"
           "ShaderDrawType = Custom;"
           "ShaderType = FX;"
>; 

sampler2D noiseSampler : register (s5)
{
  Texture = Shaders\Textures\NoiseHighFrequency.dds;
  MinFilter = POINT;
  MagFilter = POINT;
  MipFilter = POINT; 
  AddressU = Wrap;
  AddressV = Wrap;	
};

sampler2D perlinNoiseSampler : register (s6)
{
  Texture = Shaders\Textures\perlinNoise_sum.dds;
  MinFilter = POINT;
  MagFilter = POINT;
  MipFilter = POINT;
  AddressU = Wrap;
  AddressV = Wrap;	
};

sampler2D chartSampler = sampler_state
{
  Texture = $ColorChart;
};

// Specific data & View modes techniques

sampler2D noiseMapSampler : register (s5)
{
  Texture = Shaders\Textures\perlinNoiseNormal.dds;
  MinFilter = POINT;
  MagFilter = POINT;
  MipFilter = POINT;
  AddressU = Wrap;
  AddressV = Wrap;	
};

sampler2D screenMaskSampler : register (s6)
{
  Texture = textures\defaults\screen_mask.dds;
  MinFilter = LINEAR;
  MagFilter = LINEAR;
  MipFilter = LINEAR;
  AddressU = Wrap;
  AddressV = Wrap;	
};

/// Constants ////////////////////////////

float4 viewModeParams;

/// Samplers ////////////////////////////

// none

///////////////// vertex shader //////////////////

struct vtxOutVmNoisy
{
  float4 HPosition  : POSITION;
  float2 baseTC0    : TEXCOORDN;
  float2 baseTC1    : TEXCOORDN;
  float2 baseTC2    : TEXCOORDN;
  float2 baseTC3    : TEXCOORDN;
};


vtxOutVmNoisy vmNoisyVS(vtxIn IN)
{
  vtxOutVmNoisy OUT = (vtxOutVmNoisy)0; 

  float4 vPos = IN.Position;
  OUT.HPosition = mul(vpMatrix, vPos);  
  OUT.baseTC0.xy = IN.baseTC.xy;
      
  float2 scale=float2(g_VS_ScreenSize.x, g_VS_ScreenSize.y)/256;      
  float2 pixScale=1/float2(g_VS_ScreenSize.x, g_VS_ScreenSize.y);      
    
  float anim=g_VS_AnimGenParams.z;
  
  // make sure noise is correctly texel to pixel mapped 
  IN.baseTC.xy*=scale;  
    
  OUT.baseTC1.xy = IN.baseTC.xy+(viewModeParams.w*200.0, -viewModeParams.w*180.0)*pixScale;  
  OUT.baseTC2.xy = IN.baseTC.yy*0.5+(sin(anim)+sin(anim*0.5)+sin(anim*0.25))/3;
  OUT.baseTC3.yx = IN.baseTC.yy*0.5-(cos(anim)+cos(anim*0.5)+cos(anim*0.25))/3;

  return OUT;
}

///////////////// pixel shader //////////////////
pixout vmNoisyPS(vtxOutVmNoisy IN)
{
  pixout OUT;
  
  half fScale=0.2;
   
  half4 noiseColor = tex2D(_tex2, IN.baseTC1.xy);      
      
  // fetch noisy stripes
  half4 noisyColor0 = tex2D(_tex2, IN.baseTC2.xy);      
  half4 noisyColor1 = tex2D(_tex2, IN.baseTC3.xy);      
  half noisyColorA=(noisyColor0.x*0.5+noisyColor1.x*0.5)*0.3+0.7;
      
  // fetch bump noise
  half4 baseColor0 = tex2D(_tex1, IN.baseTC2.xy);      
  half4 baseColor1 = tex2D(_tex1, IN.baseTC3.xy);        
  half3 noisyBump=normalize(2*(baseColor0.xyz*0.5+baseColor1.xyz*0.5)-1);
    
  // regular noise
  half noisyColorB=(noiseColor.x);  
  
  noisyColorA=1-(1-noisyColorA)*fScale;
  noisyColorB=1-(1-noisyColorB)*fScale;
      
  half4 screenNoisyColor = tex2D(_tex0, IN.baseTC0.xy+noisyBump.xy*0.005*fScale);     
  //half4 maskColor = tex2D(screenMaskSampler, IN.baseTC0.xy);         
 
  half Lum=dot((half3)0.33333, screenNoisyColor.xyz);
  half3 Chrom = screenNoisyColor.xyz - Lum;

  OUT.Color.xyz =Lum*noisyColorA;
  OUT.Color.xyz*=(0.5+noisyColorB*0.5);  
  OUT.Color.xyz += Chrom*(2-noisyColorB);
  
  // apply screen mask
  //OUT.Color.xyz *=maskColor.xyz;  
    
  OUT.Color.w=1;

  return OUT;
}

////////////////// technique /////////////////////
technique ViewMode_Noisy
{
  pass p0
  {
    VertexShader = compile vs_Auto vmNoisyVS();            
    PixelShader = compile ps_Auto vmNoisyPS();
    CullMode = None;        
  }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// Alien Interference techniques //////////////////////////////////////////////////////////////////

///////////////// vertex shader //////////////////

struct vtxOutAlienInterference
{
  float4 HPosition  : POSITION;
  float2 baseTC0    : TEXCOORDN;
  float2 baseTC1    : TEXCOORDN;
  float2 baseTC2    : TEXCOORDN;
  float2 baseTC3    : TEXCOORDN;
};


vtxOutAlienInterference AlienInterferenceVS(vtxIn IN)
{
  vtxOutAlienInterference OUT = (vtxOutAlienInterference)0; 

  float4 vPos = IN.Position;
  OUT.HPosition = mul(vpMatrix, vPos);  
  OUT.baseTC0.xy = IN.baseTC.xy;
      
  float2 scale=float2(g_VS_ScreenSize.x, g_VS_ScreenSize.y)/256;      
  float2 pixScale=1/float2(g_VS_ScreenSize.x, g_VS_ScreenSize.y);      
    
  float anim=g_VS_AnimGenParams.z;
  
  // make sure noise is correctly texel to pixel mapped 
  IN.baseTC.xy*=scale;  
  return OUT;
}

///////////////// pixel shader //////////////////
pixout AlienInterferencePS(vtxOutAlienInterference IN)
{
  pixout OUT;
  
  half fAmount = psParams[0].w;

  float2 fScreenScale = ( PS_ScreenSize.xy / 64.0);
  
  float4 test = tex2D(noiseSampler, ((IN.baseTC0.xy  - 0.5) * (1.0 + (frac(AnimGenParams)*2-1)*0.05) + 0.5)*fScreenScale ) ;
  test += tex2D(noiseSampler, ((IN.baseTC0.xy  - 0.5) * (1.0 + (frac(AnimGenParams + 0.1)*2-1)*0.075 ) + 0.5)*fScreenScale );
  test += tex2D(noiseSampler, ((IN.baseTC0.xy  - 0.5) * (1.0 + (frac(AnimGenParams + 0.2)*2-1)*0.085 ) + 0.5)*fScreenScale );
  test += tex2D(noiseSampler, ((IN.baseTC0.xy  - 0.5) * (1.0 + (frac(AnimGenParams + 0.3)*2-1)*0.095 ) + 0.5)*fScreenScale );

  AnimGenParams*= 4*2;//*fAmount;

  test *= 0.25;

    float4 cScreen = tex2D(screenMapSampler, IN.baseTC0.xy);

  fScreenScale = ( float2(0.01, 3) )*0.01;
  float4 stripes = tex2D(perlinNoiseSampler, IN.baseTC0.xy*fScreenScale  + float2(1, 0) * (AnimGenParams*0.05) ) ;
  stripes += tex2D(perlinNoiseSampler, IN.baseTC0.xy*fScreenScale*0.99  - float2(1.1, 0) * (AnimGenParams )*0.05) ;

  stripes *= 0.5;
  fScreenScale = ( float2(0.25,0.5) );

  stripes  = saturate(stripes.x*2-1.65)*2;

  test.xy *= float2(0.15,3);
  stripes*= 2;

  stripes *= fAmount;
  test *= fAmount;
  
  float4 cScreenInterference = tex2D(screenMapSampler, (IN.baseTC0.xy-0.5)*(1.0 - test*0.0125) +0.5 + float2(0,test.x*stripes.x)).x;
  cScreenInterference.y = tex2D(screenMapSampler, (IN.baseTC0.xy-0.5)*(1.0 - test*0.025) +0.5+ float2(0,test.x*stripes.x)).y;
  cScreenInterference.z = tex2D(screenMapSampler, (IN.baseTC0.xy-0.5)*(1.0 - test*0.05) +0.5+ float2(0,test.x*stripes.x)).z;

  float4 cGhosting = tex2D(screenMapSampler, IN.baseTC0.xy + stripes*0.2*float2(0,1)*0.5 );
  cGhosting.y= tex2D(screenMapSampler, IN.baseTC0.xy + stripes*0.1*float2(0,1) *0.5);
  cGhosting.z= tex2D(screenMapSampler, IN.baseTC0.xy + stripes*0.05*float2(0,1) *0.5);

  half3 cInterference = lerp(1, float3(0.85, 0.95, 1.25), sqrt(fAmount));

  OUT.Color.xyz = max(lerp(cGhosting, cGhosting*0.1*fAmount+cScreenInterference, 1.2*saturate(stripes.x*0.5+0.5)*fAmount + 1- fAmount), 0) * cInterference;
  OUT.Color.w = 1;

  return OUT;
}

////////////////// technique /////////////////////
technique AlienInterference
{
  pass p0
  {
    VertexShader = compile vs_Auto AlienInterferenceVS();            
    PixelShader = compile ps_Auto AlienInterferencePS();
    CullMode = None;        
  }
}


////////////////////////////////////////////////////////////////////////////////////////////////////
/// Water droplets technique //////////////////////////////////////////////////////////////////////////

/// Specific data ////////////////////////

/// Constants ////////////////////////////

float4 waterDropletsParams;

/// Samplers ////////////////////////////

sampler2D waterDropletsBumpSampler
{
  Texture = Shaders/Textures/water_droplets.dds;
  MinFilter = LINEAR;
  MagFilter = LINEAR;
  MipFilter = LINEAR; 
  AddressU = Wrap;
  AddressV = Wrap;
};

sampler2D ng_hudMaskTex
{
  Texture = Shaders/Textures/HUD/nanosuit_mask.dds;
  MinFilter = LINEAR;
  MagFilter = LINEAR;
  MipFilter = LINEAR; 
  AddressU = Wrap;
  AddressV = Wrap;
};

sampler2D ng_hexOutlineTex = sampler_state
{
  Texture = Shaders/Textures/HUD/polyhydra_ddn.dds;
  MinFilter = LINEAR;
  MagFilter = LINEAR;
  MipFilter = NONE; 
  AddressU = Wrap;
  AddressV = Wrap;
};

sampler2D ng_hexGradTex
{
  Texture = Shaders/Textures/HUD/nanosuit_grad.dds;
  MinFilter = LINEAR;
  MagFilter = LINEAR;
  MipFilter = LINEAR; 
  AddressU = Wrap;
  AddressV = Wrap;
};

sampler2D ng_noiseTex
{
  Texture = Shaders/Textures/HUD/polyhedra3_ddn.dds;
  MinFilter = LINEAR;
  MagFilter = LINEAR;
  MipFilter = LINEAR; 
  AddressU = Wrap;
  AddressV = Wrap;
};

///////////////// vertex shader //////////////////

struct vtxOutWaterDroplets
{
  float4 HPosition  : POSITION;
  float2 baseTC    : TEXCOORDN;
  float4 noiseTC    : TEXCOORDN;  
};

vtxOutWaterDroplets waterDropletsVS(vtxIn IN)
{
  vtxOutWaterDroplets OUT = (vtxOutWaterDroplets)0; 

  float4 vPos = IN.Position;
  OUT.HPosition = mul(vpMatrix, vPos);  
  OUT.baseTC.xy = IN.baseTC.xy;
  
  OUT.noiseTC.xy = IN.baseTC.xy*0.5;  
  
  // animate height noise
  OUT.noiseTC.zw = IN.baseTC.xy*float2(1.0, 0.25)*0.5 + float2(0, -g_VS_AnimGenParams.w) ;
  OUT.noiseTC.z += (sin(g_VS_AnimGenParams.w) + sin(g_VS_AnimGenParams.w*0.5))*0.5 + 0.5;
    
  return OUT;
}

///////////////// pixel shader //////////////////
pixout waterDropletsPS(vtxOutWaterDroplets IN)
{
  pixout OUT;
  
#if D3D10	
  // temporary workaround for d3d10 hlsl compiler bug
  OUT.Color = tex2D(screenMapSampler, IN.baseTC.xy);;
#endif
           
  half4 noiseColorA = tex2D(waterDropletsBumpSampler, IN.noiseTC.xy);        
  half4 noiseColorB = tex2D(waterDropletsBumpSampler, IN.noiseTC.zw);        
  
  half4 screenNormalVec;
  screenNormalVec.z = (noiseColorA.z*2-1)*0.5+ (2*noiseColorB.w-1); // animate z component to simulate water movement + coesion
  screenNormalVec.xy = (noiseColorA.xy*2-1);
  
  // get refraction vector  
  half3 refrUV = normalize(screenNormalVec.xyz*float3(0.01, 0.01, 1));
  
  // fetch backbuffer and displace it
  half4 screenColor = tex2D(screenMapSampler, IN.baseTC.xy - refrUV.xy*0.25 * waterDropletsParams.w);
  
  // get fake spec highlights
  refrUV = normalize(screenNormalVec.xyz*float3(0.025, 0.025, 1));
  
  // some issue in d3d10 
  //half fSpec = clamp(pow(refrUV.x, 9)*0.5, -0.5, 0.5) * waterDropletsParams.w;
  
  half fSpec = saturate(pow(saturate(refrUV.x), 9) * 0.5) * waterDropletsParams.w;
 
  OUT.Color.xyz = screenColor.xyz + fSpec;
  OUT.Color.w = 1;

  return OUT;
}

////////////////// technique /////////////////////

technique WaterDroplets
{
  pass p0
  {
    VertexShader = compile vs_Auto waterDropletsVS();
    PixelShader = compile ps_Auto waterDropletsPS();    
    CullMode = None;    
  }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// Water flow technique //////////////////////////////////////////////////////////////////////////

/// Specific data ////////////////////////

/// Constants ////////////////////////////

float4 waterFlowParams;

/// Samplers ////////////////////////////

sampler2D waterFlowBumpSampler : register (s5)
{
  Texture = Shaders/Textures/perlinNoiseNormal.dds;
  MinFilter = LINEAR;
  MagFilter = LINEAR;
  MipFilter = LINEAR; 
  AddressU = Wrap;
  AddressV = Wrap;
};

///////////////// vertex shader //////////////////

struct vtxOutWaterFlow
{
  float4 HPosition  : POSITION;
  float2 baseTC    : TEXCOORDN;
  float4 noiseTC    : TEXCOORDN;  
  float4 noiseTC2    : TEXCOORDN;  
};

vtxOutWaterFlow waterFlowVS(vtxIn IN)
{
  vtxOutWaterFlow OUT = (vtxOutWaterFlow)0; 

  float4 vPos = IN.Position;
  OUT.HPosition = mul(vpMatrix, vPos);  
  OUT.baseTC.xy = IN.baseTC.xy;
  
  OUT.noiseTC.xy = IN.baseTC.xy*0.5;  
  
  // animate height noise
  float4 tcVertical = 0;
  tcVertical.xy = IN.baseTC.xy*float2(1.0, 0.5)*0.25 + float2(0, -g_VS_AnimGenParams.w*0.7)*0.2 *0.5;;//(sin(g_VS_AnimGenParams.w) + sin(g_VS_AnimGenParams.w*0.5))*0.5 + 0.5;
  tcVertical.zw = IN.baseTC.xy*float2(1.25, 0.1)*0.25 + float2(0, -g_VS_AnimGenParams.w*1)*0.9*0.75 ;
  OUT.noiseTC = tcVertical;

  float4 tcHorizontal = 0;
  tcHorizontal.xy = IN.baseTC.xy*float2(1.0, 1)*0.125*0.5*2 - float2(0, -g_VS_AnimGenParams.w*1.0) ;;//(sin(g_VS_AnimGenParams.w) + sin(g_VS_AnimGenParams.w*0.5))*0.5 + 0.5;
  tcHorizontal.zw = IN.baseTC.xy*float2(1.0, 1)*0.125*0.4*2 + float2(0, -g_VS_AnimGenParams.w*1.1) ;
  OUT.noiseTC2 = tcHorizontal;

  return OUT;
}

///////////////// pixel shader //////////////////
pixout waterFlowPS(vtxOutWaterFlow IN)
{
  pixout OUT;
  
#if D3D10	
  // temporary workaround for d3d10 hlsl compiler bug
  OUT.Color = tex2D(screenMapSampler, IN.baseTC.xy);
#endif
           
  half4 noiseColorA = tex2D(waterFlowBumpSampler, IN.noiseTC.xy)*2-1;        
  half4 noiseColorB = tex2D(waterFlowBumpSampler, IN.noiseTC.zw+noiseColorA.xy*0.01)*2-1;        
  
  half4 screenNormalVec0 = noiseColorA;// + noiseColorB;
  screenNormalVec0.xy = screenNormalVec0.xy*0.1 + noiseColorB.xy*10;
  screenNormalVec0.xyz = normalize( screenNormalVec0.xyz );

  noiseColorA = tex2D(waterFlowBumpSampler, IN.noiseTC2.xy)*2-1;        
  noiseColorB = tex2D(waterFlowBumpSampler, IN.noiseTC2.zw+noiseColorA.xy*0.01)*2-1;        
  
  half4 screenNormalVec1 = noiseColorA + noiseColorB;
  screenNormalVec1.xyz = normalize( screenNormalVec1.xyz );

  half4 screenNormalVec = lerp(screenNormalVec1, screenNormalVec0, saturate(CamFront.z+0.5));


  //screenNormalVec.z = (screenNormalVec.z*2-1)*0.5+ (2*screenNormalVec.w-1); // animate z component to simulate water movement + coesion
  //screenNormalVec.xy = (screenNormalVec.xy*2-1);
  // get refraction vector  
  half3 refrUV = normalize(float3(screenNormalVec.xy*(1-saturate(CamFront.z)), dot(screenNormalVec.xy, 1)));
  
  
  // fetch backbuffer and displace it
  half4 screenColorOrig = tex2D(screenMapSampler, IN.baseTC.xy); // + refrUV.xy*0.04 * waterFlowParams.w);
  half4 screenColor = tex2D(screenMapSampler, IN.baseTC.xy +refrUV.xy*0.015 * waterFlowParams.w);
  
  
  OUT.Color.xyz = lerp(screenColorOrig, screenColor, saturate(0.5+0.5*saturate(dot(screenNormalVec.xyz, 2)))*(1-saturate(CamFront.z))) ;
  OUT.Color.w = 1;

  return OUT;
}

////////////////// technique /////////////////////

technique WaterFlow
{
  pass p0
  {
    VertexShader = compile vs_Auto waterFlowVS();
    PixelShader = compile ps_Auto waterFlowPS();    
    CullMode = None;    
  }
}


////////////////////////////////////////////////////////////////////////////////////////////////////
/// Blood splats technique //////////////////////////////////////////////////////////////////////////

/// Specific data ////////////////////////

/// Constants ////////////////////////////

float4 bloodSplatsParams;

/// Samplers ////////////////////////////

sampler2D effectAccumSampler : register (s1)
{
  Texture = $EffectsAccum;
  MinFilter = LINEAR;
  MagFilter = LINEAR;
  MipFilter = POINT; 
  AddressU = Clamp;
  AddressV = Clamp; 
};


sampler2D bloodBumpSampler  : register (s2)
{
  Texture = Shaders/Textures/water_droplets.dds;
  MinFilter = LINEAR;
  MagFilter = LINEAR;
  MipFilter = LINEAR; 
  AddressU = Wrap;
  AddressV = Wrap;
};

///////////////// vertex shader //////////////////

struct vtxOutBloodSplats
{
  float4 HPosition  : POSITION;
  float2 baseTC    : TEXCOORDN;
  float4 noiseTC    : TEXCOORDN;  
};

vtxOutBloodSplats bloodSplatsVS(vtxIn IN)
{
  vtxOutBloodSplats OUT = (vtxOutBloodSplats)0; 

  float4 vPos = IN.Position;
  OUT.HPosition = mul(vpMatrix, vPos);  
  OUT.baseTC.xy = IN.baseTC.xy;
  
  OUT.noiseTC.xy = IN.baseTC.xy;  
  
  // animate height noise
  OUT.noiseTC.xy = IN.baseTC.xy + float2(0, -frac(g_VS_AnimGenParams.w * 0.025));
  OUT.noiseTC.zw = IN.baseTC.xy*2 + float2(0, -frac(g_VS_AnimGenParams.w * 0.1));
  return OUT;
}

///////////////// pixel shader //////////////////
pixout bloodSplatsGenPS(vtxOut IN)
{
  pixout OUT;           
  OUT.Color = 0.5; // just out-put half strenght - bump will take care of detail
  return OUT;
}

pixout bloodSplatsFlowPS(vtxOut IN)
{
  pixout OUT;           
  half4 vDisplace = tex2D(bloodBumpSampler, IN.baseTC.xy)*2-1;        
  // dilate texture and accumulate results
  OUT.Color = tex2D(effectAccumSampler, IN.baseTC.xy + (vDisplace.xy * 0.1 * bloodSplatsParams.w - (1-bloodSplatsParams.w) * half2(0, 0.05/ScrSize.y))  );
  return OUT;
}

pixout bloodSplatsPS(vtxOutBloodSplats IN)
{
  pixout OUT;

  half4 accumColor = tex2D(effectAccumSampler, IN.baseTC.xy);
           
  half4 noiseColorA = tex2D(bloodBumpSampler, IN.noiseTC.xy)*2-1;        
  half4 noiseColorB = tex2D(bloodBumpSampler, IN.noiseTC.zw)*2-1;
  
  half4 screenNormalVec = noiseColorA;
  
  // animate z component to simulate blood movement + coesion
  screenNormalVec.z = noiseColorA.w*0.5 + (accumColor.w*2-1)*bloodSplatsParams.w; 
    // add more bump detail
  screenNormalVec.xy += noiseColorB.xy; 
      
  // get refraction vector  
  half3 refrUV = normalize(screenNormalVec.xyz*half3(0.2, 0.2, 1));
  
  // get blood displacement accumulation and displace it a bit
  accumColor = tex2D(effectAccumSampler, IN.baseTC.xy+(refrUV.xy)*0.01);
  
  // fetch backbuffer and displace it
  half4 screenColorBloody = tex2D(screenMapScaledSampler_d4, IN.baseTC.xy +  refrUV.xy*0.01*bloodSplatsParams.w); 
  half4 screenColor = tex2D(screenMapSampler, IN.baseTC.xy);
  
  // Compose blood color  
  half4 cBlood = saturate(abs(screenNormalVec.z*0.5+0.5)) * half4(screenColorBloody.x, 0, 0, 1);
  
  // Set blood/screen blending coeficient
  half accumDepth = accumColor.w;
  accumColor.w = 1-accumColor.w;
  accumColor.w *= 2;    
  
  // Final output     
  OUT.Color.xyz = lerp(screenColor.xyz, cBlood.xyz , saturate(accumColor.w)*bloodSplatsParams.w);

  // Add fake spec highlights into final output
  refrUV = normalize(screenNormalVec.xyz * half3(1-accumDepth.xx, 1));
  half fSpec = saturate(pow(refrUV.x, 8) );
  
  OUT.Color.xyz += fSpec * bloodSplatsParams.w * 0.3 * saturate(accumColor.w);
      
  OUT.Color.w = 1;
    
  return OUT;
}

float4 CameraFrontVector : PB_CameraFront;

pixout ScreenBloodPS(vtxOut IN)
{
  pixout OUT = (pixout) 0;
  half fCenterWeight = ( length(IN.baseTC.xy*2-1));
  fCenterWeight *= fCenterWeight;
  fCenterWeight = (1.0-fCenterWeight);

  half fCenterWeightSpec = saturate(length(IN.baseTC.xy*2-1));
  fCenterWeightSpec *= fCenterWeightSpec;
  fCenterWeightSpec = (1-fCenterWeightSpec);
  
  //half fAlpha = psParams[0].z;
  half fBlendAmount = 0.2;
  half4 cBloodDeform = tex2D(waterDropletsBumpSampler, IN.baseTC.xy*0.33 )*2-1;
  half4 cBloodInputTex = tex2Dlod(waterDropletsBumpSampler, float4(IN.baseTC.xy*1.5 + float2(0, -AnimGenParams*0.0085) + cBloodDeform.xy * 0.02, 0, 1.5));

  cBloodInputTex = max(cBloodInputTex, tex2D(waterDropletsBumpSampler, IN.baseTC*2));

  half fBloodMask = saturate(cBloodInputTex.x - fCenterWeight - fBlendAmount) / (1e-6 + saturate(1 - fCenterWeight  - fBlendAmount + 0.1));
  fBloodMask = saturate( fBloodMask  );

  half fBloodMaskSpec = saturate(cBloodInputTex.x - fCenterWeightSpec) / (1e-6 + saturate(1 - fCenterWeightSpec  - fBlendAmount + 0.1)/bloodSplatsParams.w);
  fBloodMaskSpec = saturate( fBloodMaskSpec );

  CameraFrontVector.xy -= 0.5*(cBloodInputTex*2-1);
  half fDifAprox = abs( dot(normalize( CameraFrontVector.xyz), -g_PS_SunLightDir.xyz));
  half fSpecAprox = pow(saturate((bloodSplatsParams+2000)*cBloodInputTex.z*2-1 + cBloodInputTex.x*2-1)*fBloodMaskSpec, 2/2);

  half4 cScene = tex2D(screenMapSampler, IN.baseTC.xy);

  // blend mode = src color * dst color + dst color * spec
  OUT.Color.rgb = cScene * saturate(lerp(half3(1,1, 1), half3(0.6,0.0, 0.0)*(fDifAprox+0.5),fBloodMask) / bloodSplatsParams.w);
  OUT.Color.a = fSpecAprox*5;

  return OUT;
  
}

///////////////// pixel shader //////////////////
pixout ScreenBloodGlowPS(vtxOut IN)
{
  pixout OUT;

  half4 cScreen = tex2D(screenMapSampler, IN.baseTC.xy);
  half4 cBlood = tex2D(_tex1, IN.baseTC.xy);

  OUT.Color = lerp(cScreen, cBlood, saturate(cBlood.w / bloodSplatsParams.x));

  return OUT;
}

////////////////// technique /////////////////////

technique BloodSplatsGen
{
  pass p0
  {
    VertexShader = compile vs_Auto BaseVS();
    PixelShader =  compile ps_Auto bloodSplatsGenPS();
    CullMode = None;    
  }
}

technique BloodSplatsFlow
{
  pass p0
  {
    VertexShader = compile vs_Auto BaseVS();
    PixelShader =  compile ps_Auto bloodSplatsFlowPS();
    CullMode = None;    
  }
}

technique BloodSplatsFinal
{
  pass p0
  {
    VertexShader = compile vs_Auto bloodSplatsVS();
    PixelShader =  compile ps_Auto bloodSplatsPS();
    CullMode = None;    
  }
}

technique AlienBloodSplatsFinal
{
  pass p0
  {
    VertexShader = compile vs_Auto BaseVS();
    PixelShader =  compile ps_Auto ScreenBloodPS();
    CullMode = None;    
  }
}

technique AlienBloodSplatsGlow
{
  pass p0
  {
    VertexShader = compile vs_Auto BaseVS();
    PixelShader =  compile ps_Auto ScreenBloodGlowPS();
    CullMode = None;    
  }
}


////////////////////////////////////////////////////////////////////////////////////////////////////
/// Nightvision technique /////////////////////////////////////////////////////////////////////////

/// Specific data ////////////////////////

/// Constants ////////////////////////////

float4 nightVisionParamsVS;
float4 nightVisionParamsPS;

/// Samplers ////////////////////////////


///////////////// vertex shader //////////////////

struct vtxOutNightVision
{
  float4 HPosition  : POSITION;
  float2 baseTC    : TEXCOORDN;
  float4 noiseTC    : TEXCOORDN;  
  
};

vtxOutNightVision NightVisionVS(vtxIn IN)
{
  vtxOutNightVision OUT = (vtxOutNightVision)0; 

  float4 vPos = IN.Position;
  OUT.HPosition = mul(vpMatrix, vPos);  
  OUT.baseTC.xy = IN.baseTC.xy;
  
  
  float2 scale = g_VS_ScreenSize.xy / 128.0;      
  float2 pixScale = 128.0 / g_VS_ScreenSize.xy;      
          
  // make sure noise is correctly texel to pixel mapped 
  IN.baseTC.xy *= scale;          
  OUT.noiseTC.xy = IN.baseTC.xy + (nightVisionParamsVS.xy ) * pixScale;              
  OUT.noiseTC.wz = IN.baseTC.xy + (nightVisionParamsVS.zw + 0.333) * pixScale ;              
  
  return OUT;
}

///////////////// pixel shader //////////////////
pixout NightVisionPS(vtxOutNightVision IN)
{
  pixout OUT;

  int nQuality = GetShaderQuality();

  const int flareCount = (nQuality >= QUALITY_HIGH) ? 4 : 0;

  half4 cScreen = tex2D(_tex0, IN.baseTC.xy);
  half4 cScreenOrig = cScreen;

  half4 cScreenBlurred = tex2D(_tex1, IN.baseTC.xy);
  
  // sharpen screen
  cScreen =  saturate(lerp(cScreenBlurred,cScreen,  2));
  half fLum = dot(cScreen.xyz, 0.33);

  float fSceneLum = 0.5;
#if %_RT_HDR_MODE  
 fSceneLum = tex2D(_tex4, IN.baseTC.xy).x *0.125;
#endif

  // add noisy glow
  half fNoise = dot(tex2D(_tex2, IN.noiseTC.xy).xy, 0.7);
  fNoise += dot(tex2D(_tex2, IN.noiseTC.wz).xy, 0.5);
  fNoise *= 0.25;

  half fInterlation = abs(frac((IN.baseTC.y)*PS_ScreenSize.y*0.25)*2-1)*0.75+0.25;
  fNoise = (fInterlation + fInterlation*fNoise);

  // Darken edges (and lerp between 1.0 and darken term). Overbright white areas also
  half fDistToCenter = length(IN.baseTC.xy * 2 - 1);
  half fDarken = saturate( 1 - fDistToCenter*0.7);  

  half4 cScreenEdges = 0;//
  if( flareCount )
  {
    cScreenEdges = tex2D(_tex1, IN.baseTC.xy - normalize((IN.baseTC.xy+0.005*(tex2D(_tex3, IN.noiseTC.xy).xy*2-1)) * 2 - 1)*0.15);
    cScreenEdges += tex2D(_tex1, IN.baseTC.xy - normalize((IN.baseTC.xy+0.005*(tex2D(_tex3, IN.noiseTC.xy).xy*2-1)) * 2 - 1)*0.2);
    cScreenEdges += tex2D(_tex1, IN.baseTC.xy - normalize((IN.baseTC.xy+0.005*(tex2D(_tex3, IN.noiseTC.xy).xy*2-1)) * 2 - 1)*0.25);
    cScreenEdges *= 0.333;
    cScreenEdges =cScreenEdges*0.75  + 0.25 *tex2D(_tex1, IN.baseTC.xy - normalize((IN.baseTC.xy+0.005*(tex2D(_tex3, IN.noiseTC.xy).xy*2-1)) * 2 - 1)*0.4);
  }
  else
    cScreenEdges = tex2D(_tex1, IN.baseTC.xy);

  half fBlurEdges = fDistToCenter;
  fBlurEdges *= fBlurEdges;
  fBlurEdges *= fBlurEdges;

  cScreen = lerp(cScreen, cScreenEdges, saturate(fBlurEdges*0.5));
  cScreen = (cScreen  + cScreenBlurred * saturate(fNoise));
            
  fLum = dot(cScreen.xyz, 0.33);;
  
               
  // Output final color and add grainy noise on top
  OUT.Color = cScreen * fDarken;

//if %_RT_HDR_MODE  
  OUT.Color.xyz =   (1 - exp( -  4*( OUT.Color.xyz+ saturate(cScreenBlurred*1.25  -fNoise))));
//else
  //OUT.Color.xyz = fSceneLum *(fSceneLum * 0.25 + saturate(cScreenBlurred * 2 -(fNoise)   )) + (1 - exp( -4*(OUT.Color.xyz  )));
//endif
  
  // get absolute value, stuff totaly black will get whitish

  fLum = ( dot(OUT.Color.xyz, 0.33) );
  OUT.Color.xyz = tex2D(_tex3, fLum.xx);

  //OUT.Color.xyz =   (1 - exp( -( *OUT.Color.xyz) ) );
  OUT.Color.xyz= max( lerp(0.5, OUT.Color.xyz, 1.25), 0);
  OUT.Color.xyz = lerp(fLum, OUT.Color.xyz,0.65);

  OUT.Color.xyz = lerp(cScreenOrig.xyz, OUT.Color.xyz, nightVisionParamsPS.w*nightVisionParamsPS.w);

  // overbright sligthly
  //OUT.Color.xyz *= 1.25;
          
  return OUT;
}

////////////////// technique /////////////////////

technique NightVision
{
  pass p0
  {
    VertexShader = compile vs_Auto NightVisionVS();
    PixelShader =  compile ps_Auto NightVisionPS();
    CullMode = None;    
  }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// FlashBang technique //////////////////////////////////////////////////////////////////////

/// Constants ////////////////////////////

// y = difraction amount, z = pow(blindness amount, 4), w = blindness amount
float4 vFlashBangParams;

///////////////// pixel shader //////////////////

pixout FlashBangPS(vtxOut IN)
{
  pixout OUT;
  
  half4 cScreen = tex2D(_tex0, IN.baseTC.xy );      
  
  half4 cGhostImage = 0;
  cGhostImage.x = tex2D(_tex1, IN.baseTC.xy - 0.1 * (IN.baseTC.xy*2-1) * vFlashBangParams.y).x;
  cGhostImage.y = tex2D(_tex1, IN.baseTC.xy - 0.09 * (IN.baseTC.xy*2-1) * vFlashBangParams.y).y;
  cGhostImage.z = tex2D(_tex1, IN.baseTC.xy - 0.08 * (IN.baseTC.xy*2-1) * vFlashBangParams.y).z;
    
  cGhostImage = max(cGhostImage*2-0.6, 0.0) * vFlashBangParams.w;
  half fLum = dot(cGhostImage.xyz, 0.333);

  OUT.Color = lerp(cScreen +  lerp(fLum, cGhostImage, saturate(vFlashBangParams.x+0.4)),  1, saturate(vFlashBangParams.z) );
      
  return OUT;
}

////////////////// technique /////////////////////

technique FlashBang
{
  pass p0
  {
    VertexShader = compile vs_Auto BaseVS();
    PixelShader = compile ps_Auto FlashBangPS();    
    CullMode = None;        
  }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// Rain Drops technique ///////////////////////////////////////////////////////////////////////////

/// Constants ////////////////////////////

float4 vRainParams;
float4 vRainNormalMapParams;

/// Samplers ////////////////////////////

sampler2D rainDropSampler = sampler_state
{
  Texture = textures/defaults/rain_drop_b.dds;
  MinFilter = LINEAR;
  MagFilter = LINEAR;
  MipFilter = LINEAR; 
  AddressU = Wrap;
  AddressV = Wrap;
};

///////////////// vertex shader //////////////////

struct vtxOutRainDrops
{
  float4 HPosition  : POSITION;
  float2 tcBase0 : TEXCOORDN;   
  float2 tcBase1 : TEXCOORDN;   
  float2 tcBase2 : TEXCOORDN;   
};

struct vtxOutRainDropsExtinction
{
  float4 HPosition  : POSITION;     
  float2 tcNormal0 : TEXCOORDN;   
  float2 tcNormal1 : TEXCOORDN;   
  float2 tcNormal2 : TEXCOORDN;   
  float2 tcNormal3 : TEXCOORDN;   
};

vtxOutRainDropsExtinction RainDropsExtinctionVS(vtxIn IN)
{
  vtxOutRainDropsExtinction OUT = (vtxOutRainDropsExtinction)0; 

  float4 vPos = IN.Position;
  OUT.HPosition = mul(vpMatrix, vPos);    
  
  //0.0f, 0.5f, 0.85f, 1.0f)
  
  OUT.tcNormal0.xy = IN.baseTC.xy + (vRainNormalMapParams.xw - vRainNormalMapParams.yz)/ScrSize.xy;
  OUT.tcNormal1.xy = IN.baseTC.xy - (vRainNormalMapParams.xw - vRainNormalMapParams.yz)/ScrSize.xy;
  OUT.tcNormal2.xy = IN.baseTC.xy + (vRainNormalMapParams.wx - vRainNormalMapParams.yz)/ScrSize.xy;
  OUT.tcNormal3.xy = IN.baseTC.xy - (vRainNormalMapParams.wx - vRainNormalMapParams.yz)/ScrSize.xy;
      
  return OUT;
}

vtxOutRainDrops RainDropsFinalVS(vtxIn IN)
{
  vtxOutRainDrops OUT = (vtxOutRainDrops)0; 

  float4 vPos = IN.Position;
  OUT.HPosition = mul(vpMatrix, vPos);    
  OUT.tcBase0.xy = IN.baseTC.xy;  
  OUT.tcBase1.xy = IN.baseTC.xy + float2(1.0, 0.0) / ScrSize.x;
  OUT.tcBase2.xy = IN.baseTC.xy + float2(0.0, 1.0) / ScrSize.y;

  return OUT;
}

///////////////// pixel shader //////////////////

// technique done in 3 passes
//  - 1 pass renders rain drops into rain map
//  - 2 pass blurs/dilates out results continuosly to simulate water extinction/running through screen
//  - 3 pass generates a normal map from rain drops heightmap and blends rain with frame buffer

pixout RainDropsGenPS(vtxOut IN)
{
  pixout OUT;
    
  half4 cRainDrops = tex2D(rainDropSampler, IN.baseTC.xy);        
    
  // ellipsoidal shape
  
  
  const float2 vRads = float2( 1.5, 1 );  
  float2 vEllipse = float2( cos( IN.baseTC.x*2-1 + PI*0.5), sin( IN.baseTC.y *2-1) ) * vRads ;  
  
  OUT.Color =  (1 - saturate(pow( length( vEllipse.xy ), 8) ));
  
  
  //float2 vPos = float2( IN.baseTC.xy*2-1  );  
  //float blob = exp( -10 * sqrt( dot( vPos, vPos ) ) );
  //float blob = 1 - smoothstep( 0, 0.75, dot( vPos, vPos ) );
  //OUT.Color = blob * 0.5 + 0.5; // * 0.1;
  

  float2 vPos = float2( IN.baseTC.xy*2-1  );  
  float blob = sqrt( saturate( 1 - dot( vPos, vPos ) ) ) ;
//  OUT.Color = cRainDrops.x; //blob;// * 0.5 + 0.5;
  
  // circle shape
  //OUT.Color = (1-length(IN.baseTC.xy*2-1))  ; //* vRainParams.w
              
  return OUT;
}

pixout RainDropsExtinctionPS(vtxOutRainDropsExtinction IN)
{
  pixout OUT = (pixout) 0;
  
  // Apply dilation
  
  float fCenterWeights = tex2D( _tex0, IN.tcNormal0.xy ).x;                
  
  float4 vWeights = 0;    
  vWeights.x = tex2D( _tex0, IN.tcNormal0.xy ).x;  
  vWeights.y = tex2D( _tex0, IN.tcNormal1.xy ).x;
  vWeights.z = tex2D( _tex0, IN.tcNormal2.xy ).x;
  vWeights.w = tex2D( _tex0, IN.tcNormal3.xy ).x;
              
  vWeights.x = (vWeights.x > vWeights.y)? vWeights.x: vWeights.y;
  vWeights.y = (vWeights.z > vWeights.w)? vWeights.z: vWeights.w;  
  vWeights.x = (vWeights.x > vWeights.y)? vWeights.x: vWeights.y;                                   // 3 cmps
  
  //OUT.Color = dot(vWeights, 0.25) - 0.005; // * 0.98 ; //
  
  // subtract constant value for attenuation  
  //OUT.Color = dot(vWeights, 0.25) > 0.5 ? dot(vWeights, 0.25) - 0.005: 0.5; // * 0.98 ; //                                                    
  OUT.Color = dot(vWeights, 0.25) - 0.1 * vRainParams.w; // * 0.98 ; //                                                    
      
  return OUT;
}


pixout RainDropsFinalPS(vtxOutRainDrops IN)
{
  pixout OUT = (pixout) 0;
#if D3D10	
  // temporary workaround for d3d10 hlsl compiler bug
  OUT.Color = tex2D(_tex0, IN.tcBase0.xy);
#endif

        
  half fRainDrops = tex2D(_tex1, IN.tcBase0.xy).x;
  
  ///////////////////////////////////////////////////////////////////////////////////////////////////  
  // Generate rain normal map (cheap sobel filter)
      
  float3 vWeights = 0;    
  vWeights.x = (tex2D( _tex1, IN.tcBase0.xy ).x);
  vWeights.y = (tex2D( _tex1, IN.tcBase1.xy ).x);
  vWeights.z = (tex2D( _tex1, IN.tcBase2.xy ).x);
  
  // make it a bit sharper (maybe add a sharpening control)
  vWeights = saturate( vWeights *2 - 1 );
      
  float3 vNormal = float3( vWeights.x - vWeights.y, vWeights.x - vWeights.z, 0.5);                  // 2 adds
  vNormal = normalize(vNormal.xyz);                                                                 // 1 nrm
  
  //float fSpec = pow( saturate(vNormal.y) * 3, 5 ) ;                                  
  float fSpec = pow( saturate(vNormal.x + vNormal.y), 8 )*0.25;// *2;                                    // 1 mul, 1 pow

  float3x3 tangentToWorld = float3x3( CameraRight.xyz, CameraUp.xyz, CamFront.xyz );
  float3 vSunTangent = normalize( mul( tangentToWorld, g_PS_SunLightDir.xyz ) );

  float3 vHalf = normalize( float3(0, 0, 1) + vSunTangent.xyz);
  float NdotL = abs( dot(vSunTangent.xy, float2(1,-1) * vNormal.xy) );// * saturate( fRainDrops*2.0); // saturate(dot(vNormal, -vSunTangent.xyz)) * saturate( fRainDrops*2.0) ;
  //float NdotH = fSpec* (1-NdotL);
  
  fSpec += saturate(pow(NdotL, 4))*0.25; //0.1 +  NdotH;

  //fSpec += pow( saturate(ble.y) * 3, 8 ) ;                                 
                                                              // 1 nrm  
  half4 cScreen = 0;  
  cScreen.x = tex2D(_tex0, IN.tcBase0.xy - vNormal.xy * 0.08 *0.5).x;                                 // 1 mad
  cScreen.y = tex2D(_tex0, IN.tcBase0.xy - vNormal.xy * 0.1 *0.5 ).y;                                 // 1 mad
  cScreen.z = tex2D(_tex0, IN.tcBase0.xy - vNormal.xy * 0.12*0.5).z;                                 // 1 mad
    
  OUT.Color.xyz = (g_PS_SunColor.xyz) * fSpec + cScreen.xyz;// + fSpec;                                                                   // 1 add
     
  //OUT.Color.xyz = vNormal.xyz * 0.5 + 0.5;
  //OUT.Color = fRainDrops;// + tex2D(_tex0, IN.tcBase.xy);
     
  return OUT;
}

////////////////// technique /////////////////////

technique RainDropsGen
{
  pass p0
  {
    VertexShader = compile vs_Auto BaseVS();
    PixelShader = compile ps_Auto RainDropsGenPS();    
    CullMode = None;        
  }
}

technique RainDropsExtinction
{
  pass p0
  {
    VertexShader = compile vs_Auto RainDropsExtinctionVS();
    PixelShader = compile ps_Auto RainDropsExtinctionPS();    
    CullMode = None;        
  }
}

technique RainDropsFinal
{
  pass p0
  {
    VertexShader = compile vs_Auto RainDropsFinalVS();
    PixelShader = compile ps_Auto RainDropsFinalPS();    
    CullMode = None;        
  }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// Chameleon cloak technique //////////////////////////////////////////////////////////////////////

/// Constants ////////////////////////////

///////////////// pixel shader //////////////////

pixout ChameleonCloakEffectPS(vtxOut IN)
{
  pixout OUT;
  
  half4 cScreen = tex2D(_tex0, IN.baseTC.xy );      
      
  OUT.Color = cScreen;
  OUT.Color.w =0.15;// 0.215;
      
  return OUT;
}

////////////////// technique /////////////////////

technique ChameleonCloakEffect
{
  pass p0
  {
    VertexShader = compile vs_Auto BaseVS();
    PixelShader = compile ps_Auto ChameleonCloakEffectPS();    
    CullMode = None;        
  }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// Stylized filter technique /////////////////////////////////////////////////////////////////////////

sampler2D grainNoiseSampler = sampler_state
{
  Texture = Shaders\Textures\vector_noise.dds;
  MinFilter = POINT;  
  MagFilter = POINT;
  MipFilter = POINT; 
  AddressU = Wrap;
  AddressV = Wrap;
};

pixout StylizedFilterPS(vtxOut IN)
{
  pixout OUT = (pixout) 1;
  
  
  half4 acc = 0;

  float2 vNoiseTC = (IN.baseTC.xy ) * (PS_ScreenSize.xy/64.0) +  (psParams[0].xy/PS_ScreenSize.xy);
  float2 vNoise = tex2D(grainNoiseSampler, vNoiseTC)+ dot(IN.baseTC.xy, 1) * 65535;
  vNoise = frac( vNoise );

  vNoise = vNoise*2-1;
  //vNoise *= 0.05;

  half4 cScreen = tex2D(screenMapSampler, IN.baseTC);
  half4 cScreenBlur = tex2D(screenMapScaledSampler_d2, IN.baseTC);

  cScreen = lerp(cScreenBlur, cScreen, 2);
  

  float fDepth = tex2D(depthMapSampler, IN.baseTC).x;

  float lum = dot(cScreen, float3(0.33, 0.59, 0.11));
  float4  c= lerp(lum, cScreenBlur, 0.025);// * float4(0.7, 1, 0.9, 1);

  float x = 1-length(cScreenBlur - float3(1, 1, 1)); 
  float3 reds =max( float3(x*1.5, x*0.75, x*0.25)-0.25, 0);

  x = 1-length(cScreenBlur - float3(1, 0, 0)); 
  reds +=max( float3(x, 0,0)-0.25, 0);

/*
  x = 1-length(cScreen - float3(0, 1, 0)); 
  reds = float3(0, x, 0);
  c.y= saturate(reds.y);

  x = 1-length(cScreen - float3(0, 0, 1)); 
  reds = float3(0, 0, x);
  c.z = saturate(reds.z);
*/
  OUT.Color =c;// lerp(cScreen, c, saturate(fDepth*10000) );// + dot(vNoise.xy, 0.5)*0.05;//psParams[0].w;
  OUT.Color.xyz = lum + reds;



  //OUT.Color.xyz = float3(1-length(cScreen - float3(1, 0, 0)), 0, 0);

  //OUT.Color.xyz = lum;

  //OUT.Color.xyz = reds;
  
  //OUT.Color = lerp(cScreen, cScreenBlur, saturate( (1-saturate(fDepth*25000))*20 ));// + dot(vNoise.xy, 0.5)*0.05;//psParams[0].w;

  
  OUT.Color += dot(vNoise.xy, 0.5)*0.1;//psParams[0].w;


  return OUT;
}

////////////////// technique /////////////////////

technique StylizedFilter
{
  pass p0
  {
    VertexShader = compile vs_Auto BaseVS();            
    PixelShader = compile ps_Auto StylizedFilterPS();
    CullMode = None;        
  }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// Binocular-view technique /////////////////////////////////////////////////////////////////////////

// optimization todo: pass offsets through constants

struct vtxOutBinocularView
{
  float4 HPosition  : POSITION;
  float4 baseTC0     : TEXCOORD0;
  float4 baseTC1     : TEXCOORD1;
  float4 baseTC2     : TEXCOORD2;
  float4 baseTC3     : TEXCOORD3;
};

vtxOutBinocularView BinocularViewVS(vtxIn IN)
{
  vtxOutBinocularView OUT = (vtxOutBinocularView)0; 

  float4 vPos = IN.Position;
  OUT.HPosition = mul(vpMatrix, vPos);  
  OUT.baseTC0.xy = IN.baseTC.xy;
  OUT.baseTC1.xy = IN.baseTC.xy + 3*float2(0, -1) * ScrSize.zw;
  OUT.baseTC2.xy = IN.baseTC.xy + 3*float2(-1, 1) * ScrSize.zw;
  OUT.baseTC3.xy = IN.baseTC.xy + 3*float2(1, 1) * ScrSize.zw;

  return OUT;
}

pixout BinocularViewPS(vtxOutBinocularView IN)
{
  pixout OUT = (pixout) 1;

  half4 c = tex2D(_tex0, IN.baseTC0);
  half4 c0 = tex2D(_tex0, IN.baseTC1);
  half4 c1 = tex2D(_tex0, IN.baseTC2);
  half4 c2 = tex2D(_tex0, IN.baseTC3);

  half3 edges = 0;  
  edges.x = c.w - c0.w;
  edges.y = c.w - c1.w;
  edges.z = c.w - c2.w;
  edges = ( (abs(edges)))>0;

  half fSilhouete = dot(edges.xyz, 1.333); // 1.333 = 0.333 avg * 4.0 for overbrighting

  float d = tex2D(_tex1, IN.baseTC0 ).x;
  float d0 = tex2D(_tex1, IN.baseTC1 ).x;
  float d1 = tex2D(_tex1, IN.baseTC2  ).x;
  float d2 = tex2D(_tex1, IN.baseTC3 ).x;
  float3 cSilhoueteMask = float3(d0, d1, d2) < d;

  // Silhouete color masking - need to make sure to get correct color for silhouette
  half4 cSilhouetteColor =  0 ;
  cSilhouetteColor +=  c0 * cSilhoueteMask.x;
  cSilhouetteColor +=  c1 * cSilhoueteMask.y;
  cSilhouetteColor +=  c2 * cSilhoueteMask.z;
  cSilhouetteColor.xyz /= dot(cSilhoueteMask.xyz, 1) + 0.0001;

  half fOpacity = saturate( dot( c.xyz + c0.xyz + c1.xyz + c2.xyz, 10) ); 

  OUT.Color.xyz = ( (cSilhouetteColor * 0.5* fOpacity *fSilhouete) + c * 0.2 * psParams[0].w );

  return OUT;
}

pixout BinocularViewGlowPS(vtxOut IN)
{
  pixout OUT = (pixout) 1;
  half4 c = tex2D(_tex0, IN.baseTC);
  half4 cSilhouettes = tex2D(_tex1, IN.baseTC);

  // remove body tinting from glow, only leave silhouettes
  OUT.Color = max(cSilhouettes - c * 0.2, 0.0);

  return OUT;
}

pixout BinocularViewFinalPS(vtxOut IN)
{
  pixout OUT = (pixout) 1;
    
  half4 cScreen = tex2D(_tex0, IN.baseTC);
  half4 cSilhouettes = tex2D(_tex1, IN.baseTC);
  half4 cSilhouettesBlurred = tex2D(_tex2, IN.baseTC);

  half fInterlation = abs(frac((IN.baseTC.y)*PS_ScreenSize.y*0.25)*2-1)*0.5+0.5;
  half fVigneti = saturate( 1 - length(IN.baseTC.xy - 0.5)*0.6 );

  //OUT.Color =  fInterlation *1.5* (  cScreen * half4( 0.6, 0.7, 1.0, 1.0) )+ (cSilhouettesBlurred + cSilhouettes*saturate(fInterlation*2-1)*1.5)*0.666;
  OUT.Color =  fInterlation *1.5* (  cScreen * half4( 0.7, 0.8, 1.0, 1.0) )+ (cSilhouettesBlurred + cSilhouettes*saturate(fInterlation*2-1)*1.5)*0.666;
  OUT.Color *= fVigneti;

  OUT.Color = lerp(cScreen, OUT.Color, psParams[0].w);
  

  return OUT;
}

pixout BinocularViewFinalNoTintingPS(vtxOut IN)
{
  pixout OUT = (pixout) 1;
    
  half4 cScreen = tex2D(_tex0, IN.baseTC);
  half4 cSilhouettes = tex2D(_tex1, IN.baseTC);
  half4 cSilhouettesBlurred = tex2D(_tex2, IN.baseTC);

  half fInterlation = abs(frac((IN.baseTC.y)*PS_ScreenSize.y*0.25)*2-1)*0.5+0.5;

  OUT.Color =  cScreen + (cSilhouettesBlurred*0.5 + dot(cSilhouettes.xyz, 0.33)*0.1);
  OUT.Color = lerp(cScreen, OUT.Color, psParams[0].w);

  return OUT;
}

////////////////// technique /////////////////////

technique BinocularView
{
  pass p0
  {
    VertexShader = compile vs_Auto BinocularViewVS();            
    PixelShader = compile ps_Auto BinocularViewPS();
    CullMode = None;        
  }
}

technique BinocularViewGlow
{
  pass p0
  {
    VertexShader = compile vs_Auto BaseVS();            
    PixelShader = compile ps_Auto BinocularViewGlowPS();
    CullMode = None;        
  }
}

technique BinocularViewFinal
{
  pass p0
  {
    VertexShader = compile vs_Auto BaseVS();            
    PixelShader = compile ps_Auto BinocularViewFinalPS();
    CullMode = None;        
  }
}

technique BinocularViewFinalNoTinting
{
  pass p0
  {
    VertexShader = compile vs_Auto BaseVS();            
    PixelShader = compile ps_Auto BinocularViewFinalNoTintingPS();
    CullMode = None;        
  }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// Color grading technique /////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

float4 ColorGradingParams0;
float4 ColorGradingParams1;
float4 ColorGradingParams2;
float4 ColorGradingParams3;
float4 ColorGradingParams4;
float4 mColorGradingMatrix[3];

sampler2D grainSampler = sampler_state
{
  Texture = Shaders\Textures\vector_noise.dds;
  MinFilter = POINT;  
  MagFilter = POINT;
  MipFilter = POINT; 
  AddressU = Wrap;
  AddressV = Wrap;
};

////////////////////////////////////////////////////////////////////////////////////////////////////

void AddNoise( float2 tc, inout half3 cImage)
{
  float2 tcNoise = (tc.xy ) * (PS_ScreenSize.xy/64.0) +  (ColorGradingParams1.zw/PS_ScreenSize.xy);
  float2 vNoise = tex2D(grainSampler, tcNoise)+ dot(tc.xy, 1) * 65535;
  vNoise = frac( vNoise );
  vNoise = vNoise*2-1;

  cImage += dot(vNoise.xy, 0.1) * ColorGradingParams1.y;
}

////////////////////////////////////////////////////////////////////////////////////////////////////

void AdjustLevels( inout half3 cImage )
{
  half fMinInput = ColorGradingParams0.x;
  half fGammaInput = 1.0 / ColorGradingParams0.y;
  half fMaxInput = ColorGradingParams0.z;
  half fMinOutput = ColorGradingParams0.w;
  half fMaxOutput = ColorGradingParams1.x;

  cImage.xyz = pow( max( (cImage.xyz * 255.0f - fMinInput) / (fMaxInput - fMinInput), 0.0f), fGammaInput);
  cImage.xyz *= (fMaxOutput - fMinOutput);
  cImage.xyz += fMinOutput;
  cImage.xyz /= 255.0;
}

////////////////////////////////////////////////////////////////////////////////////////////////////

void ApplyPhotoFilter( inout half4 cImage )
{
  half3 cFilterColor = ColorGradingParams2.xyz;
  half fFilterColorDensity = ColorGradingParams2.w;

  half3 vLum = half3(0.33, 0.59, 0.11);
  half fLum = dot(cImage.xyz, vLum);

  half3 cMin = 0;
  half3 cMed = cFilterColor;
  half3 cMax = 1.0;

  half3 cColor = lerp(cMin, cMed , saturate( fLum * 2.0 ) );
  cColor = lerp( cColor, cMax, saturate( fLum - 0.5 ) * 2.0 );

  cImage.xyz = lerp( cImage.xyz, cColor.xyz , saturate( fLum * fFilterColorDensity ) );
}

////////////////////////////////////////////////////////////////////////////////////////////////////

void AdjustColor( inout half4 cImage )
{
  // do a dp4 instead, saves 3 adds  
  cImage.xyz = half3( dot(cImage, mColorGradingMatrix[0]), 
                      dot(cImage, mColorGradingMatrix[1]), 
                      dot(cImage, mColorGradingMatrix[2]) );;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Color conversions

half4 RGBtoCMYK( float3 rgb )
{
  half4 cmyk = 0.0;
  cmyk.xyz = 1.0 - rgb;

  cmyk.w = saturate( min( min(cmyk.x, cmyk.y), cmyk.z ) );
  cmyk.xyz = saturate( (cmyk.xyz - cmyk.w) / (1.0 - cmyk.w) );

  return cmyk;
}

////////////////////////////////////////////////////////////////////////////////////////////////////

float3 CMYKtoRGB( float4 cmyk )
{
  half3 rgb = 0.0;
  rgb = 1.0 - min(1.0, cmyk.xyz * (1.0 - cmyk.w) + cmyk.w);
  return rgb;
}

////////////////////////////////////////////////////////////////////////////////////////////////////

void SelectiveColor( inout half3 cImage )
{
  half fColorPickRange = saturate(1 - length( cImage.xyz - ColorGradingParams3.xyz) );

  half4 cmyk = RGBtoCMYK( cImage.xyz );
  cmyk = lerp( cmyk, clamp(cmyk+ColorGradingParams4, -1, 1), fColorPickRange);
  cImage =lerp( cImage, CMYKtoRGB( cmyk ), fColorPickRange);
}

////////////////////////////////////////////////////////////////////////////////////////////////////

pixout ColorGradingPS(vtxOut IN)
{
  pixout OUT = (pixout) 0;

  half4 cImage = half4( tex2D(screenMapSampler, IN.baseTC.xy).xyz, 1.0);


#if %_RT_SAMPLE1

  // Unsharpening
  half4 cImageScaledDown = tex2D( screenMapScaledSampler_d2, IN.baseTC.xy );
  cImage = lerp(cImageScaledDown, cImage, ColorGradingParams3.w);

  // Noise filter
  AddNoise( IN.baseTC.xy, cImage.xyz );

#endif

#if %_RT_SAMPLE0

  // Levels adjustment
  AdjustLevels( cImage.xyz );

#endif

#if %_RT_SAMPLE1

  // Photo filter
  ApplyPhotoFilter( cImage );

#endif

  // General color adjustment
  AdjustColor(cImage );
  
#if %_RT_SAMPLE2

  // Selective color adjustment
  SelectiveColor( cImage.xyz );;

#endif

  OUT.Color.xyz = cImage;

  return OUT;
}

////////////////// technique /////////////////////

technique ColorGrading
{
  pass p0
  {
    VertexShader = compile vs_2_0 BaseVS() GeneralVS;            
    PixelShader = compile ps_2_x ColorGradingPS() GeneralPS;
    CullMode = None;        
  }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// Water volume texgen technique //////////////////////////////////////////////////////////////////////////

/// Specific data ////////////////////////

float4 waterVolumesParams;

pixout waterVolumesNormalGenPS(vtxOut IN)
{
  pixout OUT;

  float p0 = tex2D( _tex0, IN.baseTC.xy ).z;
  float p1 = tex2D( _tex0, IN.baseTC.xy + float2(1,0) /waterVolumesParams.w).z;
  float p2 = tex2D( _tex0, IN.baseTC.xy + float2(0,1)/waterVolumesParams.w).z;

  float v0 = p1-p0;
  float v1 = p2-p0;

  float3 vNormal = float3(float2(v0, v1), 4);
  vNormal = normalize( vNormal.xyz );                                                              // 3 inst
 
  OUT.Color.xyz = vNormal*0.5+0.5;
  OUT.Color.w = clamp(p0 /20.0, -1.0, 1.0)*0.5+0.5;//vWeights.x*0.5+0.5;

  return OUT;
}

technique WaterVolumesNormalGen
{
  pass p0
  {
    VertexShader = compile vs_Auto BaseVS();
    PixelShader = compile ps_Auto waterVolumesNormalGenPS();    
    CullMode = None;    
  }
}


////////////////////////////////////////////////////////////////////////////////////////////////////
/// Screen condensation technique //////////////////////////////////////////////////////////////////

// todo: cleanup

float4 ScreenCondensation;

/// Specific data ////////////////////////

sampler2D condensationBumpSampler = sampler_state
{    
  Texture = textures/defaults/screencondensation.dds;
  MinFilter = LINEAR;
  MagFilter = LINEAR;
  MipFilter = LINEAR; 
  AddressU = Wrap;
  AddressV = Wrap;
};


///////////////// vertex shader //////////////////

struct vtxOutScreenCondensation
{
  float4 HPosition  : POSITION;
  float2 baseTC    : TEXCOORDN;
  float4 noiseTC0    : TEXCOORDN;  
  float2 noiseTC1    : TEXCOORDN;  
  float2 noiseTC2    : TEXCOORDN;  
};

vtxOutScreenCondensation ScreenCondensationVS(vtxIn IN)
{
  vtxOutScreenCondensation OUT = (vtxOutScreenCondensation)0; 

  float4 vPos = IN.Position;
  OUT.HPosition = mul(vpMatrix, vPos);  
  OUT.baseTC.xy = IN.baseTC.xy;
  
  OUT.noiseTC0.xy = IN.baseTC.xy+ float2(frac(vsParams[0].ww )); 
    
  OUT.noiseTC1 = IN.baseTC.xy*2+ float2(frac(vsParams[0].ww - AnimGenParams.x*0.01));  
  OUT.noiseTC2 = IN.baseTC.xy*4 + float2(frac(vsParams[0].ww + AnimGenParams.x*0.02));
  return OUT;
}

float4 CameraFrontVector : PB_CameraFront;

///////////////// pixel shader //////////////////
pixout ScreenCondensationPS(vtxOutScreenCondensation IN)
{
  pixout OUT = (pixout) 0;
  half fCenterWeight = ( length(IN.baseTC.xy*2-1));
  fCenterWeight *= fCenterWeight;
  fCenterWeight = (1-fCenterWeight);

  half fCenterWeightSpec = saturate(length(IN.baseTC.xy*2-1));
  fCenterWeightSpec *= fCenterWeightSpec;
  fCenterWeightSpec = (1-fCenterWeightSpec);
  
  //half fAlpha = psParams[0].z;
  half fBlendAmount = 0;
  half4 cBloodDeform = tex2D(waterDropletsBumpSampler, IN.baseTC.xy*0.33 )*2-1;
  half4 cBloodInputTex = tex2Dlod(waterDropletsBumpSampler, float4(IN.baseTC.xy*1.5 + float2(0, -AnimGenParams*0.0085) + cBloodDeform.xy * 0.02, 0, 1.5));

  cBloodInputTex = max(cBloodInputTex, tex2D(waterDropletsBumpSampler, IN.baseTC*2)*ScreenCondensation.w);

  half fBloodMask = saturate(cBloodInputTex.x - fCenterWeight - fBlendAmount) / (1e-6 + saturate(1 - fCenterWeight  -fBlendAmount + 5));
  fBloodMask = saturate( fBloodMask );

  half fBloodMaskSpec = saturate(cBloodInputTex.x - fCenterWeightSpec - fBlendAmount) / (1e-6 + saturate(1 - fCenterWeightSpec  -fBlendAmount + 5)+bloodSplatsParams.w);
  fBloodMaskSpec = saturate( fBloodMaskSpec );

  CameraFrontVector.xy -= 0.5*(cBloodInputTex*2-1);
  half fDifAprox = abs( dot(normalize( CameraFrontVector.xyz), -g_PS_SunLightDir.xyz));
  half fSpecAprox = pow(saturate((ScreenCondensation+2000)*cBloodInputTex.z*2-1 + cBloodInputTex.x*2-1)*fBloodMaskSpec, 2/2);

  half4 cScene = tex2D(screenMapSampler, IN.baseTC.xy);

  // blend mode = src color * dst color + dst color * spec
  OUT.Color.rgb = cScene * saturate(lerp(half3(1,1, 1), half3(0.6,0.0, 0.0)*(fDifAprox+0.5), fBloodMask) / ScreenCondensation.w);
  OUT.Color.a = fSpecAprox*5;

  return OUT;
}

////////////////// technique /////////////////////

technique ScreenCondensation
{
  pass p0
  {
    VertexShader = compile vs_Auto ScreenCondensationVS();
    PixelShader = compile ps_Auto ScreenCondensationPS();
    CullMode = None;    
  }
}



////////////////////////////////////////////////////////////////////////////////////////////////////
/// Screen Frost technique /////////////////////////////////////////////////////////////////////////

/// Specific data ////////////////////////

/// Constants ////////////////////////////

float4 screenFrostParamsVS;
float4 screenFrostParamsPS;

float4x4 mViewProj < vsregister = c0; >;

/// Samplers ////////////////////////////

sampler2D frostBumpSampler = sampler_state
{    
  Texture = textures/defaults/screenfrost.dds;
  MinFilter = LINEAR;
  MagFilter = LINEAR;
  MipFilter = LINEAR; 
  AddressU = Wrap;
  AddressV = Wrap;
};


///////////////// vertex shader //////////////////

struct vtxOutScreenFrost
{
  float4 HPosition  : POSITION;
  float2 baseTC    : TEXCOORDN;
  float4 noiseTC    : TEXCOORDN;
  float4 screenPos  : TEXCOORDN;  
};

vtxOutScreenFrost ScreenFrostVS(vtxIn IN)
{
  vtxOutScreenFrost OUT = (vtxOutScreenFrost)0; 

  float4 vPos = IN.Position;
  OUT.HPosition = mul(vpMatrix, vPos);  
  OUT.baseTC.xy = IN.baseTC.xy;

  float2 scale = g_VS_ScreenSize.xy / 128.0;      
  float2 pixScale = 128.0 / g_VS_ScreenSize.xy; 

  IN.baseTC.xy *= scale;          
  OUT.noiseTC.xy = IN.baseTC.xy + (screenFrostParamsVS.xy ) * pixScale;              
  OUT.noiseTC.wz = IN.baseTC.xy + (screenFrostParamsVS.zw + 0.333) * pixScale;
  return OUT;
}

struct vtxOutNanoGlass
{
  float4 screenPos  : TEXCOORDN;
  float2 baseTC     : TEXCOORDN;
};

vtxOutNanoGlass NanoGlassVS(vtxIn IN)
{
  vtxOutNanoGlass OUT = (vtxOutNanoGlass) 0;

  OUT.baseTC = IN.baseTC; 
  OUT.HPosition = mul(mViewProj, float4(IN.Position.xyz, 1));
    OUT.screenPos = HPosToScreenTC(OUT.HPosition);
    
  return OUT;
}

pixout NanoGlassPS(vtxOutNanoGlass IN)
{
  pixout OUT;

  #define ng_hexTexScale          9.0
  #define hexOutlineMin         1.0
  #define ng_backBufferBrightessScalar  10.0
  #define ng_vignetteTexOffset        0.1
  #define ng_vignetteSaturation     0.1
  #define ng_animPos                10.0
  #define ng_noiseThresh            1.0
  #define ng_time             0.112
  #define ng_brightnessScale        10.0
  #define ng_noiseTime            0.04
  #define ng_movementWaveStrength     100.0
  #define ng_vignetteFallOffScale     1.0
  #define ng_movementWaveFrequency      8.0
  #define ng_movementStrength       10.0
  #define ng_noiseStrength          0.10
  #define ng_vignetteStrength       -1.0
  #define ng_effectAlpha          1.0
  #define ng_mistAlpha            2.1
  #define ng_vignetteScreenScale      1
  #define ng_hexColor           0.2,0.5,0.0
  #define ng_hitStrength          1.0
  #define ng_overChargeStrength 1.0
  #define ng_cornerGlowStrength 0.5
  #define refractionScale       1.0

  #define ng_noiseTexScale           0.8
  #define ng_noiseScale           18.75
  #define ng_vignetteAlphaSaturation      0.4
  #define ng_vignetteAlphaSaturationReScale 1.11
  #define refractionNoiseTCScale      3.0
  #define refractionNoiseSaturation     2.0
  #define refractionNoiseScale        0.3

  #define ng_menuNoise              0.5
  #define ng_menuNoiseHighlight   0.4
  #define ng_menuNoiseScale       0.5
  #define ng_maxBrightnessScale   1.7
  #define ng_interlationHitStrengthBoost  0.25
  #define ng_noiseHitStrengthBoost 0.1

  half texOffsetScale = 1;
  half2 screenTC = IN.screenPos.xy / IN.screenPos.w;
  half2 visorTC = IN.baseTC.xy;
  half2 hexTC = (visorTC - half2(0.5,0.5)) * ng_hexTexScale * texOffsetScale;
  half2 vecDistFromCentre = abs(visorTC - half2(0.5,0.5)) * 2;
  half animAlpha = 1.0;

  const half halfHexScreenSize = 0.0501;
  const half hexAnimRange = 0.4;
  const half hexGradientScale = 0.25;
  
  // Sample and unpack hexagon data
  half3 hexDir = tex2D(ng_hexOutlineTex, hexTC).xyz;
  hexDir.xy = normalize((hexDir.xy * 2.0) - 1.0);
  half hexGradient = tex2D(ng_hexGradTex, hexTC * hexGradientScale).x;

  // Calculate distance from nearest hexagon center to screen center
  half2 screenPos = abs((visorTC * 2.0) - 1.0);
  screenPos += hexDir.xy * hexDir.z * halfHexScreenSize;
  half screenCenterDist = length(screenPos);
  
  // Clip hexagons outside the animation range
  animAlpha = step(ng_animPos, screenCenterDist + hexGradient * hexAnimRange);

  half2 vecDistFromCentreSq = (vecDistFromCentre * vecDistFromCentre * ng_vignetteScreenScale) * screenFrostParamsPS.w;
  half vignetteAlpha = (vecDistFromCentreSq.x + vecDistFromCentreSq.y);

  vignetteAlpha += (1.0-vignetteAlpha) * (1.0-(ng_vignetteStrength)); // Apply vignette strength
  vignetteAlpha = pow(vignetteAlpha,4); // Control vignette falloff
  vignetteAlpha = saturate(max(vignetteAlpha-ng_vignetteAlphaSaturation,0.9) * ng_vignetteAlphaSaturationReScale); // Saturate alpha slightly

  
  //half vTexOutline = tex2Dlod(ng_hexOutlineTex,half4(hexTC,0.0,0.0));
  half noiseMask = 1.0 - tex2D(ng_noiseTex, IN.baseTC*8);
  
  half cornerGlow = 0;
  const half cornerGlowPow = 3;
  cornerGlow = visorTC.y*vecDistFromCentre.x;
  cornerGlow = pow(cornerGlow,cornerGlowPow) * ng_cornerGlowStrength;
  
  half fCenterWeight = saturate( length(visorTC.xy*2-1));

  half fCenterWeightSpec = length(visorTC.xy*2-1)-screenFrostParamsPS.w;
  fCenterWeightSpec = saturate(2.0-fCenterWeightSpec);

  //fCenterWeight *= fCenterWeight;
  fCenterWeight = saturate(min(1.3-fCenterWeight,1));


  half fCenterNoise = saturate( length(visorTC.xy *2-1))*screenFrostParamsPS.z;
  fCenterNoise *= 10+fCenterNoise;
  fCenterNoise = saturate(min(10-fCenterNoise,1));

  half fCenterNoiseY = saturate( length(visorTC.xy *2-1))*screenFrostParamsPS.w;
  fCenterNoiseY *= 10+fCenterNoiseY;
  fCenterNoiseY = saturate(min(10-fCenterNoiseY,1));

#if %_RT_SAMPLE1
    fCenterNoise = (6.2-fCenterNoise)+14;
#endif

  half fBlendAmount = 0;
  //*************************************************************************************************************
  // Outline color
  half vTexOutline = tex2Dlod(ng_hexOutlineTex,half4(hexTC,0.0,0.0));

  //*************************************************************************************************************
  // Hex mask
  half mistTexOutline = vTexOutline;
  half hexMask = lerp(vTexOutline,mistTexOutline,ng_mistAlpha)*screenFrostParamsPS.w;

  //*************************************************************************************************************
  // Noise (2 noise samples, going in opposite directions)
  half noise = 0.0;
  half mistNoiseCombined = 0.0;
  half noiseCombined = 0.0;
  half2 noiseTC = visorTC*ng_noiseTexScale;
  half3 vNoise = tex2D(ng_hexGradTex,noiseTC + float2(-ng_noiseTime,0.0));
  noiseCombined = vNoise.x;
  vNoise = tex2D(ng_hexGradTex, noiseTC + float2(ng_noiseTime,0.0));
  noiseCombined += vNoise.x;
  noiseCombined *= 0.5;

  noiseCombined = max(noiseCombined-ng_noiseThresh,0.0) * ng_noiseScale;
  noiseCombined *= hexMask;
  mistNoiseCombined = noiseCombined * ng_mistAlpha;
  half mistNoiseCombinedx4 = mistNoiseCombined*mistNoiseCombined*mistNoiseCombined*mistNoiseCombined;
  half mistNoise = ((noiseCombined*ng_menuNoise) + (mistNoiseCombinedx4*ng_menuNoiseHighlight))*ng_menuNoiseScale;
  noise = lerp(noiseCombined,mistNoise,ng_mistAlpha-ng_overChargeStrength);
  
  noise *= 1.0 + (ng_hitStrength*ng_noiseHitStrengthBoost);
  noise *= ng_noiseStrength;

  //*************************************************************************************************************        
  // Interlacing
  const half interlaceSpacing = 0.3;
  half interlation = abs((frac(visorTC.y*PS_ScreenSize.y*interlaceSpacing)*2.0)-1.0)*0.5+0.5;
  interlation += ng_hitStrength * ng_interlationHitStrengthBoost;
  noise *= lerp(interlation,1.0,ng_mistAlpha);
  //*************************************************************************************************************

  //*************************************************************************************************************
  // Sin wave movement offset
  half sinWaveOffset = sin(ng_time+((visorTC.x+visorTC.y)*ng_movementWaveFrequency))*ng_movementWaveStrength - abs(frac(AnimGenParams*0.1)*170);
  texOffsetScale += sinWaveOffset;

  half sinWaveOffsetMin = sin(ng_time+((visorTC.x+visorTC.y)*ng_movementWaveFrequency))*ng_movementWaveStrength + abs(frac(AnimGenParams*0.1)*170);
  texOffsetScale += sinWaveOffset;

  half alphaNoiseStrength = 1.0;
  alphaNoiseStrength = lerp(alphaNoiseStrength,interlation,ng_overChargeStrength);

  half fBloodMask = saturate(hexMask.x - fBlendAmount - fCenterWeight) / (1e-6 + saturate(1.5 - fCenterWeight  -fBlendAmount + 0.1));
  fBloodMask = saturate( fBloodMask * interlation) /hexMask;


#if %_RT_SAMPLE1
  fBloodMask -= fCenterWeight / hexMask+0.1;
#endif

  fBloodMask /= hexMask;
  fBloodMask -= fCenterWeight;
  
  half4 cScene = tex2D(screenMapSampler, IN.baseTC.xy);
  half hudMask = 0.0 - tex2D(ng_hudMaskTex, screenTC).w;

  vTexOutline /= abs((frac(visorTC.xy * PS_ScreenSize.xy*ng_noiseScale)*0.1)-0.50 )*0.5+0.7;
  vTexOutline *= lerp(interlation,1,3) /  abs(frac(vecDistFromCentre.x+3*PS_ScreenSize.y*AnimGenParams*0.0002)*1-0.5);

  
  OUT.Color.rgb = cScene * saturate( lerp(half3(1,1,1), half3(0.1,0.1, 0.2), fBloodMask*1.5));
 // if(screenFrostParamsPS.w > 0)
 // {
  OUT.Color.xyz /= saturate((vTexOutline-0.1) / abs(frac(2*vecDistFromCentre.x+0.02*PS_ScreenSize.y*sinWaveOffsetMin.x*0.002)*1-0.5)*interlation*0.23 + (fCenterNoise/screenFrostParamsPS.z));
//  }
  OUT.Color.gb /= saturate((vTexOutline+0.2) / abs(frac(2.1*vecDistFromCentre.x+0.005*PS_ScreenSize.y*sinWaveOffset.x*0.002)*1-0.5)*interlation*0.25 + (fCenterNoiseY/screenFrostParamsPS.w));

  //OUT.Color.xyz /= saturate((vTexOutline) / abs(frac(0.1*vecDistFromCentre.x+0.005*PS_ScreenSize.y*sinWaveOffset.x*0.002)*1-0.5)*interlation*0.25 + (fCenterNoiseY/screenFrostParamsPS.w));

#if &_RT_SAMPLE1
    // Maximum Suit nanoGlass [OperationSalvage]
    OUT.Color.rgb = cScene * saturate( lerp(half3(1,1,1), half3(0.1,0.1, 0.2), fBloodMask-0.2));
    OUT.Color.b /= saturate(((vTexOutline-0.15/screenFrostParamsPS.w) / abs(frac(2*vecDistFromCentre.x+0.1*PS_ScreenSize.x*AnimGenParams*0.004)*1-0.5)*interlation+3.7+cornerGlow));
    fBloodMask += hexMask ;
    fBloodMask = saturate( fBloodMask * interlation+2);
    //OUT.Color.y *= saturate((vTexOutline/screenFrostParamsPS.w) / abs(frac(6*vecDistFromCentre.x+0.2*PS_ScreenSize.x*AnimGenParams*0.002)*1-0.5)*interlation*0.25 + fCenterNoise);
    fBloodMask *= cornerGlow-0.07;
    fBloodMask *= hexMask;
    OUT.Color.rgb += cScene * saturate(cornerGlow)*alphaNoiseStrength*screenFrostParamsPS.w;
    OUT.Color.b += saturate(fBloodMask);
#endif

  return OUT;
}

////////////////// technique /////////////////////

technique ScreenFrost
{
  pass p0
  {
    VertexShader = compile vs_Auto ScreenFrostVS();
    PixelShader = compile ps_Auto NanoGlassPS();
    CullMode = None;    
  }
}


/////////////////////// eof ///

